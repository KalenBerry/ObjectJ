package cellcycle;import java.applet.Applet;import java.awt.*;import java.awt.event.*;import java.awt.Color;import java.text.*;import java.awt.Graphics;import java.awt.datatransfer.Clipboard;import java.awt.datatransfer.ClipboardOwner;import java.awt.datatransfer.Transferable;import java.net.URL;import javax.swing.JFrame;public class Applet4 extends java.applet.Applet implements ClipboardOwner {  static String VERSION = "1.22";  static String DATE = "27-feb-2012aaaa";  public static String newline = System.getProperty("line.separator");  String versionString = "Version = " + VERSION + newline + "Date = " + DATE + newline + "N. Vischer" + newline + "Univ. Amsterdam";  boolean testFlag1 = false;  boolean testFlag2 = false;  static int myNum;  static boolean treeBusy = false, plotBusy = false;  public static String definitions[] = new String[10];  public static String caseNames[] = new String[10];  Turtle tu;  Settings se = new Settings();  public MyParams pa = new MyParams();  Font courier12 = new Font("Monospaced", 0, 12);  Font courier10 = new Font("Monospaced", 0, 10);  Font courier9 = new Font("Monospaced", 0, 9);  Graphics appletGraphics = getGraphics();  int massPolyLineX[], massPolyLineY[], dnaPolyLineX[], dnaPolyLineY[], iArrX3[], iArrY3[],          cDNAPolyLineX[], cDNAPolyLineY[];  double[] auxMass, auxGenom, auxTime;  double[] timeArr, massAllArr, massCellArr, genomeArr, genPerNucArr, genomeAllArr;  double[] forkInitArr, forkSegArr;  int forks;  int copies = 1;  boolean runFlag = false;  boolean initDone = false;  double parTime, parTD1;  int[] levelArr, typeArr;  int[] leftEndsArr, rightEndsArr, leftEndsAllArr, rightEndsAllArr, nNucsArr;  int xx1[], xx2[], yy1[], yy2[], xx1Flower[], xx2Flower[], dirFlower[];  int CDx1[], CDx2[], CDy1[], CDy2[];  Color CDcolor[];  Color ccc[];  Event myEvent;  String text3 = "";  public static boolean caseDirty = true;  public static double leftAvgMass, rightAvgMass, currentGenome;  int nlines, CDlines, flowerLines = 0, maxLevel, currentLevel;  double chromRad;  final int OCTAVES = 8;  public final static int k480 = 480;  final int plotPanelWidth = k480;  final int plotPanelHeight = 200;  final int bueboxHeight = plotPanelHeight;  static final int treePanelTop = 266;  final int xx_10 = 4;  final int xx_40 = 432;  final int yy_30 = 256;  final double kk100 = 100;  double ASPECT = 0.4;  int xStart = -180;  int xStop = plotPanelWidth + xStart;  static final int copyOffsetY = 18;  static final int copyOffsetX = 4;  int treeImgWidth = 220;  int treeImgHeight = 200;  int treePanelWidth = treeImgWidth + 4 * copyOffsetX;  int treePanelHeight = treeImgHeight + 4 * copyOffsetY;  final int wallPanelWidth = treePanelWidth;  final int wallPanelHeight = 50;  int terPosX = treeImgWidth / 2;  int terPosY = treeImgHeight - 7;  int yPos;  int maxRow = 1, lastPoint1, lastPoint2, lastPoint3,          octHeight = (int) plotPanelHeight / OCTAVES; // 8 octaves  int treeYCenter;  int yBottom, yTop;  final int maxi = 1000;  final int nullID = 0, divideID = 2, divideID2 = 3, cDoneID = 4, initID = 5, transID = 6, nucSepID = -2, nucSepID2 = -1;  static final int noValue = -99;  final int xx120 = 176, ww124 = 140, ww110 = 110, ww60 = 80, hh90 = 140, yy140 = 160, y220 = 226;  final int preCycles = 3, minusCycles = 4;  final double MiGrain = 100;  final int scrollOffset = 0, kk50 = 40;  double startTrans, stopTrans;  double currentMass, currentMass2;  int currentLeftEnds, currentRightEnds, currentnNucs;  Image offscreenImg;  Image imGenomeLabel, imMassLabel, imcDNALabel;  URL url;  int xPos = 0;  Image plotOffscreenImg, treeOffscreenImg, treePanelOffscreenImg, frameOffscreenImg, wallOffscreenImg;  Graphics plotOffscreenPort, treeOffscreenPort, treePanelOffscreenPort, frameOffscreenPort, wallOffscreenPort;  TextArea textArea1 = new TextArea("", 100, 20, TextArea.SCROLLBARS_NONE);  TextArea clipArea = new TextArea("My Clipboard text");  //TextArea numbersArea = new TextArea("");//SCROLLBARS_VERTICAL_ONLY);  TextArea numbersArea = new TextArea("", 100, 20, TextArea.SCROLLBARS_NONE);  TextArea textArea3 = new TextArea("", 100, 20, TextArea.SCROLLBARS_BOTH);  Label labelVersion = new Label();  Label labelTD1 = new Label();  Label labelC1 = new Label();  Label labelD1 = new Label();  Label labelN1 = new Label();  Label labelTD2 = new Label();  Label labelC2 = new Label();  Label labelD2 = new Label();  Label labelN2 = new Label();  Label labelMi1 = new Label();  Label labelMi2 = new Label();  Label labelL2 = new Label();  Label[] labelSet = {labelTD1, labelTD2, labelC1, labelC2, labelD1, labelD2, labelN1, labelN2, labelMi1, labelMi2, labelL2};  String[] labelNames = {" TD1= ", " TD2= ", " C1 = ", " C2 = ", " D1 = ", " D2 = ", " N1 = ", " N2 = ", " Mi1= ", " Mi2= ", " E/C = "};  // TD1-TD2-C1-C2-D1-D2-N1-N2-Mi1-Mi2-L2  double[] multiplier = {1, 1, 1, 1, 1, 1, 1, 1, 100, 100, 100};  Scrollbar scrollbarTD1 = new Scrollbar();  Scrollbar scrollbarC1 = new Scrollbar();  Scrollbar scrollbarD1 = new Scrollbar();  Scrollbar scrollbarN1 = new Scrollbar();  Scrollbar scrollbarMi1 = new Scrollbar();  Scrollbar scrollbarTD2 = new Scrollbar();  Scrollbar scrollbarC2 = new Scrollbar();  Scrollbar scrollbarD2 = new Scrollbar();  Scrollbar scrollbarN2 = new Scrollbar();  Scrollbar scrollbarMi2 = new Scrollbar();  Scrollbar scrollbarL2 = new Scrollbar();  Scrollbar[] scrollSet = {scrollbarTD1, scrollbarTD2, scrollbarC1, scrollbarC2, scrollbarD1, scrollbarD2, scrollbarN1, scrollbarN2, scrollbarMi1, scrollbarMi2, scrollbarL2};  Scrollbar scrollbarTime = new Scrollbar();  Scrollbar scrollbarViewAngle = new Scrollbar();  Checkbox checkboxGenome = new Checkbox();  Checkbox checkboxGperNuc = new Checkbox();  Checkbox checkboxMass = new Checkbox();  Checkbox checkboxcDNA = new Checkbox();  Checkbox checkboxStraight = new Checkbox();  Checkbox checkboxAnimatedPlot = new Checkbox();  Button dumpButton = new Button();  Button resetButton = new Button();  Button runButton = new Button();  plotAxesPanel plotAxesPanel = new plotAxesPanel();  PlotPanel plotPanel = new PlotPanel();  TreePanel treePanel = new TreePanel();  WallPanel wallPanel = new WallPanel();  CalcCycle myCalc = new CalcCycle();  boolean isStandalone = false;  private Choice cases;  public Applet4() {  }  public void lostOwnership(Clipboard clip, Transferable cont) {  }  // Retrieve the value of an applet parameter  public String getParameter(String key, String def) {    return isStandalone ? System.getProperty(key, def)            : (getParameter(key) != null ? getParameter(key) : def);  }  // Get info on the applet parameters  public String[][] getParameterInfo() {    String info[][] = {      {"n_string", "String", ""}    };    return info;  }  // Get applet information  public String getAppletInfo() {    return "Applet Information";  }  public String str8(String s) {    do {      s = " " + s;    } while ((s.length() % 8) != 0);    return s;  }  public String str16(String s) {    do {      s = " " + s;    } while ((s.length() % 16) != 0);    return s;  }  public String str82(double value) {    DecimalFormat myFormatter = new DecimalFormat("###.##");    String s = myFormatter.format(value);    if (value == noValue) {      s = "";    }    do {      s = " " + s;    } while ((s.length() % 8) != 0);    return s;  }  public String str80(double value) {    DecimalFormat myFormatter = new DecimalFormat("###");    String s = myFormatter.format(value);    if (value == noValue) {      s = "";    }    do {      s = " " + s;    } while ((s.length() % 8) != 0);    return s;  }  public void n_print(String s) {    if (s.equals("clear")) {      text3 = "";    } else {      text3 = text3 + s + newline;    }    textArea3.setText(text3);  }  public void toon(String s, double val) {    text3 = text3 + str16(s) + str82(val) + newline;  }  public void toon(String s) {    text3 = text3 + s + newline;  }  public void toon() {    textArea3.setText(text3);  }  public static double range(double min, double val, double max) {    if (val < min) {      return min;    }    if (val > max) {      return max;    }    return val;  }  public void advance(int stepper) {    int thiscase = stepper % 4;    int label_scrollDiscrepancy = 6;    switch (thiscase) {      case 0:        xPos = 10;        yPos += label_scrollDiscrepancy + 24;        break;      case 1:        xPos += ww60 + 2;        yPos -= label_scrollDiscrepancy;        break;      case 2:        xPos += 140;        yPos += label_scrollDiscrepancy;        break;      case 3:        xPos += ww60 + 2;        yPos -= label_scrollDiscrepancy;        break;      default:        ;    }  }  public void numbersToText() {    //puts current parameters to text and switches to case 0    xStart = (int) (-pa.TD1 * preCycles);    String ss = "";    ss = ss + pa.name;    ss = ss + newline + " Time = " + str(pa.currentTime + xStart);    ss = ss + newline + " TD1  = " + str(pa.TD1);    ss = ss + newline + " TD2  = " + str(pa.TD2);    ss = ss + newline + " C1   = " + str(pa.C1);    ss = ss + newline + " C2   = " + str(pa.C2);    ss = ss + newline + " D1   = " + str(pa.D1);    ss = ss + newline + " D2   = " + str(pa.D2);    ss = ss + newline + " N1   = " + str(pa.N1);    ss = ss + newline + " N2   = " + str(pa.N2);    ss = ss + newline + " E/C  = " + str(pa.L2);    ss = ss + newline + " Mi1  = " + str(pa.Mi1);    ss = ss + newline + " Mi2  = " + str(pa.Mi2);    ss = ss + newline;    pa.txt = ss;  }  public void paint(Graphics g) {  }  // Initialize the applet  public void init() {    try {      SimpleThread sttt = new SimpleThread();      tu = new Turtle();      treeOffscreenImg = createImage(treeImgWidth, treeImgHeight);      treePanelOffscreenImg = createImage(treePanelWidth, treePanelHeight);      plotOffscreenImg = createImage(plotPanelWidth, plotPanelHeight);      frameOffscreenImg = createImage(plotPanelWidth, plotPanelHeight);      wallOffscreenImg = createImage(wallPanelWidth, wallPanelHeight);      treeOffscreenPort = treeOffscreenImg.getGraphics();      ((Graphics2D) treeOffscreenPort).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);      treePanelOffscreenPort = treePanelOffscreenImg.getGraphics();      plotOffscreenPort = plotOffscreenImg.getGraphics();      ((Graphics2D) plotOffscreenPort).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);      ((Graphics2D) plotOffscreenPort).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);      frameOffscreenPort = frameOffscreenImg.getGraphics();      ((Graphics2D) frameOffscreenPort).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);      wallOffscreenPort = wallOffscreenImg.getGraphics();      ((Graphics2D) wallOffscreenPort).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);      cases = new Choice();      cases.setSize(140, 24);      for (int ii = 0; ii < 6; ii++) {//25.2.2012        cases.addItem(se.nameSet[ii]);      }      if (false) {        cases.addItem("----");        for (int ii = 6; ii <= 10; ii++) {          cases.addItem("Case #" + ii);        }        cases.addItem("Store current settings in Case #...");      }      cases.addItem("----");      cases.addItem("Show Version");      se.txtToNumbers(pa);      checkboxMass.setState(true);      checkboxGenome.setState(false);      checkboxcDNA.setState(false);      setCase(1);///////////////////////////////////      massPolyLineX = new int[maxi];      massPolyLineY = new int[maxi];      dnaPolyLineX = new int[maxi];      dnaPolyLineY = new int[maxi];      cDNAPolyLineX = new int[maxi];      cDNAPolyLineY = new int[maxi];      auxMass = new double[maxi];      auxGenom = new double[maxi];      auxTime = new double[maxi];      iArrX3 = new int[maxi];      iArrY3 = new int[maxi];      timeArr = new double[maxi];      forkInitArr = new double[maxi];      forkSegArr = new double[maxi];      typeArr = new int[maxi];      levelArr = new int[maxi];      massAllArr = new double[maxi];      massCellArr = new double[maxi];      genomeArr = new double[maxi];      genomeAllArr = new double[maxi];      genPerNucArr = new double[maxi];      leftEndsArr = new int[maxi];      rightEndsArr = new int[maxi];      rightEndsAllArr = new int[maxi];      leftEndsAllArr = new int[maxi];      nNucsArr = new int[maxi];      for (int n = 0; n < maxi; n++) {        massCellArr[n] = noValue;      }      xx1 = new int[maxi];      xx2 = new int[maxi];      xx1Flower = new int[maxi];      xx2Flower = new int[maxi];      dirFlower = new int[maxi];      yy1 = new int[maxi];      yy2 = new int[maxi];      CDx1 = new int[maxi];      CDx2 = new int[maxi];      CDy1 = new int[maxi];      CDy2 = new int[maxi];      CDcolor = new Color[maxi];      ccc = new Color[maxi];      url = getClass().getResource("LabelGenome.gif");      imGenomeLabel = getToolkit().getImage(url);      url = getClass().getResource("LabelMass.gif");      imMassLabel = getToolkit().getImage(url);      url = getClass().getResource("cDNA.gif");      imcDNALabel = getToolkit().getImage(url);      initComponents();      initMore();      clipArea.setEditable(true);//27.12.2010      clipArea.setEnabled(true);      initDone = true;    } catch (Exception e) {      e.printStackTrace();    }  }  public void initMore() {    labelC1.setForeground(Color.red);    labelC2.setForeground(Color.red);    labelD1.setForeground(Color.blue);    labelD2.setForeground(Color.blue);    checkboxcDNA.setForeground((new java.awt.Color(0, 128, 0)));    checkboxGenome.setForeground(Color.MAGENTA);    scrollbarTD1.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarTD1AdjustmentValueChanged();      }    });    scrollbarC1.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarC1AdjustmentValueChanged();      }    });    scrollbarD1.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarD1AdjustmentValueChanged();      }    });    scrollbarN1.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarN1AdjustmentValueChanged();      }    });    scrollbarMi1.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarMi1AdjustmentValueChanged();      }    });    scrollbarTD2.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarTD2AdjustmentValueChanged();      }    });    scrollbarC2.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbar5AdjustmentValueChanged();      }    });    scrollbarD2.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarD2AdjustmentValueChanged();      }    });    scrollbarN2.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarN2AdjustmentValueChanged();      }    });    scrollbarMi2.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarMi2AdjustmentValueChanged();      }    });    scrollbarL2.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarL2AdjustmentValueChanged();      }    });    scrollbarTime.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarTimeAdjustmentValueChanged();        pa.currentTime = scrollbarTime.getValue() + 0.00022;// dirty trick      }    });    scrollbarViewAngle.addAdjustmentListener(new AdjustmentListener() {      public void adjustmentValueChanged(AdjustmentEvent e) {        scrollbarViewAngleAdjustmentValueChanged();      }    });    dumpButton.addActionListener(new ActionListener() {      public void actionPerformed(ActionEvent e) {        DoPrintEventChain();        myCalc.buildEventChain();        myCalc.enterDivisions();        myCalc.sortEventChain();        myCalc.enterMass();        myCalc.calcLevels();        myCalc.logEvents();        myCalc.CandD();      }    });    runButton.addActionListener(new ActionListener() {      public void actionPerformed(ActionEvent e) {        if (runFlag) {          setRunFlagFalse();        } else {          runFlag = true;        }        if (runFlag) {          runButton.setLabel("Stop");        } else {          runButton.setLabel("Run");        }      }    });    resetButton.addActionListener(new ActionListener() {      public void actionPerformed(ActionEvent e) {        doReset();      }    });    textArea1.setFont(courier12);    numbersArea.setFont(courier12);    if (testFlag1) {      textArea3.setFont(courier12);    }    int kk = 10;    labelVersion.setFont(new Font("Monospaced", 0, 10));    //  Demo to intitialize the Applet with parameters from HTML tags:    //parTime = Tools.parseDouble( getParameter("Time"));    //parTD1 = Tools.parseDouble(getParameter("TD1"));    labelVersion.setText("v" + VERSION + "  " + DATE);    //labelView.setFont(new Font("Monospaced", 0, 10));    //labelView.setText("view angle");    // TD1-TD2-C1-C2-D1-D2-N1-N2-Mi1-Mi2-L2    double[] paramSet = {pa.TD1, pa.TD2, pa.C1, pa.C2, pa.D1, pa.D2, pa.N1, pa.N2, pa.Mi1, pa.Mi2, pa.L2};    for (int bb = 0; bb < paramSet.length; bb++) {      labelSet[bb].setFont(courier12);      labelSet[bb].setText(labelNames[bb] + str(paramSet[bb]));    }    scrollbarTD1.setValue((int) pa.TD1);    scrollbarTD1.setMinimum(20);    scrollbarTD1.setMaximum(20 * kk);//22-12-2010    scrollbarTD2.setValue((int) pa.TD2);    scrollbarTD2.setMinimum(20);    scrollbarTD2.setMaximum(20 * kk);    scrollbarC1.setValue((int) pa.C1);    scrollbarC1.setMinimum(20);    scrollbarC1.setMaximum(13 * kk);//13.7.2006    scrollbarC2.setValue((int) pa.C2);    scrollbarC2.setMinimum(10);    scrollbarC2.setMaximum(13 * kk);//13.7.2006    scrollbarD1.setValue((int) pa.D1);    scrollbarD1.setMinimum(5);    scrollbarD1.setMaximum(80);    scrollbarN1.setValue((int) pa.N1);    scrollbarN1.setMinimum(0);    scrollbarN1.setMaximum(80);    scrollbarD2.setValue((int) pa.D2);    scrollbarD2.setMinimum(5);    scrollbarD2.setMaximum(80);    scrollbarN2.setValue((int) pa.N2);    scrollbarN2.setMinimum(0);    scrollbarN2.setMaximum(80);//28.12.2010    scrollbarMi1.setMinimum(50);    scrollbarMi1.setMaximum(250);    scrollbarMi1.setValue((int) (pa.Mi1 * MiGrain));    scrollbarMi2.setMinimum(50);    scrollbarMi2.setMaximum(250);    scrollbarMi2.setValue((int) (pa.Mi2 * MiGrain));    scrollbarL2.setMinimum(0);    scrollbarL2.setMaximum(100);    scrollbarL2.setValue(0);    scrollbarTime.setMinimum(0);    scrollbarTime.setMaximum(xStop - xStart + 10);    scrollbarTime.setValue((int) pa.currentTime);    scrollbarViewAngle.setMinimum(0);    scrollbarViewAngle.setMaximum(110);    scrollbarViewAngle.setValue(40);    String osname = System.getProperty("os.name");    String osversion = System.getProperty("os.version");    if (osname.endsWith("X") && (osversion.compareTo("10.7") >= 0)) {      //System.out.print(">= 10.7");      scrollbarTD1.setBlockIncrement(1);      scrollbarTD2.setBlockIncrement(1);      scrollbarC1.setBlockIncrement(1);      scrollbarC2.setBlockIncrement(1);      scrollbarD1.setBlockIncrement(1);      scrollbarD2.setBlockIncrement(1);      scrollbarN1.setBlockIncrement(1);      scrollbarN2.setBlockIncrement(1);      scrollbarMi1.setBlockIncrement(1);      scrollbarMi2.setBlockIncrement(1);      scrollbarL2.setBlockIncrement(1);      scrollbarTime.setBlockIncrement(1);    }    myCalc.buildEventChain();    myCalc.enterDivisions();    myCalc.sortEventChain();    myCalc.calcLevels();    myCalc.enterMass();    myCalc.logEvents();    myCalc.CandD();    plotAxesPanel.setDirty();    plotPanel.setDirty();  }  public void initComponents() throws Exception {    // the following code sets the frame's initial state    plotPanel.setLocation(xx120, 10);    plotPanel.setVisible(true);    plotPanel.setSize(k480, plotPanelHeight);    wallPanel.setSize(wallPanelWidth, wallPanelHeight);    wallPanel.setVisible(true);    plotAxesPanel.setLocation(xx120 - 30, 0);    plotAxesPanel.setVisible(true);    plotAxesPanel.setSize(550 + kk50, 224);    textArea1.setLocation(2, yy140);    textArea1.setForeground(Color.black);    textArea1.setVisible(true);    textArea1.setBackground(new Color(200, 222, 233));    textArea1.setFont(courier12);    textArea1.setColumns(100);    textArea1.setSize(ww124, 100);    textArea1.setEditable(false);    numbersArea.setLocation(2, 10);    numbersArea.setForeground(Color.black);    numbersArea.setVisible(true);    numbersArea.setBackground(new Color(200, 222, 233));    numbersArea.setFont(courier12);    numbersArea.setColumns(100);    numbersArea.setSize(ww124, bueboxHeight);    numbersArea.setEditable(false);    if (testFlag1) {      textArea3.setLocation(750, 10);      textArea3.setSize(650, 840);      textArea3.setVisible(true);      textArea3.setBackground(new Color(200, 255, 233));    }    xPos = 10;    yPos = 350;    int stepper = 0;    for (int qq = 0; qq < scrollSet.length; qq++) {      advance(stepper++);      if (qq == 10) {//the eclipse..        xPos += 100;        yPos += 5;      }      labelSet[qq].setLocation(xPos, yPos);      labelSet[qq].setVisible(true);      labelSet[qq].setSize(ww60, 18);      advance(stepper++);      scrollSet[qq].setLocation(xPos, yPos);      scrollSet[qq].setOrientation(Scrollbar.HORIZONTAL);      scrollSet[qq].setSize(ww110, 20);    }    scrollbarTime.setLocation(xx120 + scrollOffset, y220);    scrollbarTime.setOrientation(java.awt.Scrollbar.HORIZONTAL);    scrollbarTime.setSize(k480, 18);    scrollbarViewAngle.setLocation(462, 522);    scrollbarViewAngle.setOrientation(java.awt.Scrollbar.HORIZONTAL);    scrollbarViewAngle.setSize(180, 18);    labelVersion.setLocation(2, bueboxHeight + 16);    labelVersion.setVisible(true);    labelVersion.setSize(ww124, 18);    checkboxMass.setSize(180, 18);    checkboxMass.setLabel("Cell Mass");    checkboxMass.setState(true);    checkboxGenome.setSize(180, 18);    checkboxGenome.setLabel("DNA per cell");    checkboxGenome.setState(true);//27.12.2010    checkboxcDNA.setSize(180, 18);    checkboxcDNA.setLabel("DNA per Mass");    checkboxcDNA.setState(true);//27.12.2010    checkboxStraight.setSize(240, 18);    checkboxStraight.setLabel("Straight / View Angle");    checkboxAnimatedPlot.setSize(180, 18);    checkboxAnimatedPlot.setLabel("Animated Plot");    checkboxGperNuc.setSize(180, 18);    checkboxGperNuc.setLabel("DNA per nucleoid");    yPos = 260;    resetButton.setLocation(xx120 + 80, yPos);    runButton.setLocation(xx120, yPos);    yPos += 34;    wallPanel.setLocation(xx120, yPos);    yPos = 230;    cases.setLocation(xx_10, yPos);    yPos += 34;    checkboxMass.setLocation(xx_10, yPos);    yPos += 20;    checkboxGenome.setLocation(xx_10, yPos);    yPos += 20;    checkboxcDNA.setLocation(xx_10, yPos);    yPos += 20;    checkboxStraight.setLocation(462, 500);    if (testFlag1) {      checkboxGperNuc.setLocation(xx_10, yPos);      yPos += 20;    }    checkboxAnimatedPlot.setLocation(xx_10, yPos);    yPos = 226;    if (testFlag1) {      yPos = 268;      dumpButton.setLocation(xx120, 358);      dumpButton.setLabel("Dump Data ->");      dumpButton.setVisible(true);      dumpButton.setSize(80, 20);    }    resetButton.setLabel("Reset");    resetButton.setVisible(true);    resetButton.setSize(60, 24);    runButton.setLabel("Run");    runButton.setVisible(true);    runButton.setSize(60, 24);    treePanel.setSize(treePanelWidth, treePanelHeight);    treePanel.setLocation(xx_40, treePanelTop);    treePanel.setVisible(true);    plotPanel.setBackground(new java.awt.Color(240, 255, 255));    setLocation(0, 0);    setLayout(null);    add(plotPanel);    add(plotAxesPanel);    add(numbersArea);    add(wallPanel);    add(cases);    if (testFlag1) {      add(textArea3);    }    //add(labelVersion);//27.12.2010    add(scrollbarTD1);    add(labelSet[0]);    add(scrollbarC1);    add(labelC1);    add(scrollbarD1);    add(labelD1);    add(scrollbarN1);    add(labelN1);    add(scrollbarTD2);    add(labelTD2);    add(scrollbarC2);    add(labelC2);    add(scrollbarD2);    add(labelD2);    add(scrollbarN2);    add(labelN2);    add(scrollbarMi1);    add(labelMi1);    add(scrollbarMi2);    add(labelMi2);    add(scrollbarL2);    add(labelL2);    add(scrollbarTime);    add(scrollbarViewAngle);    add(resetButton);    add(runButton);    add(checkboxcDNA);    add(checkboxGenome);    add(checkboxStraight);    //add(checkboxAnimatedPlot);//27.12.2010    if (testFlag1) {      add(checkboxGperNuc);    }    add(checkboxMass);    if (testFlag1) {      add(dumpButton);    }    add(treePanel);    setSize(700 + kk50, 540);  }  public static String str(double val) {    String s = "";    s = NumberFormat.getInstance().format(val);    if (val == noValue) {      s = "";    }    double rem;    do {      s = s + " ";      rem = (s.length() % 8);    } while (rem != 0);    return s;  }  public int round(double val) {    return (int) Math.round(val);  }  public void doReset() {    setRunFlagFalse();    while (treeBusy || plotBusy);    runButton.setLabel("Run");    se.txtToNumbers(pa);    ASPECT = 0.4;    scrollbarViewAngle.setValue(40);    setCase(1);  }  public void printEventChain() {    int tt;    String stype = "       ";    if (testFlag1) {      //                 1234567 1234567 1234567 1234567 1234567 1234567 1234567 1234567 1234567 1234567 1234567 1234567      textArea3.setText("row     time    type    massAll genomAl genom   gPNuc   leftE   rightE  nNucs   lEndsAl rEndsAl\r");      for (int row = 1; row <= 80; row++) {        tt = typeArr[row];        if (tt == nullID) {          stype = "null    ";        }        if (tt == initID) {          stype = "init    ";        }        if (tt == divideID) {          stype = "divid***";        }        if (tt == divideID2) {          stype = "divide2 ";        }        if (tt == cDoneID) {          stype = "cdone   ";        }        if (tt == nucSepID) {          stype = "nucsep  ";        }        if (tt == nucSepID2) {          stype = "nucsep2 ";        }        textArea3.appendText(str(row) + str(timeArr[row])                + stype + str(massAllArr[row])                + str(genomeAllArr[row])                + str(genomeArr[row]) + str(genPerNucArr[row])                + str(leftEndsArr[row]) + str(rightEndsArr[row]) + str(nNucsArr[row])                + str(leftEndsAllArr[row]) + str(rightEndsAllArr[row])                + newline);      }    }  }  public void scrollbarTD1AdjustmentValueChanged() {    labelTD1.setText(" TD1= " + str(scrollbarTD1.getValue()));    pa.TD1 = scrollbarTD1.getValue();    plotPanel.setDirty();    plotAxesPanel.setDirty();    treePanel.setVisible(true);//21.8.2006    numbersArea.setText("");  }  public void updateControls() {    double[] paramSet = {pa.TD1, pa.TD2, pa.C1, pa.C2, pa.D1, pa.D2, pa.N1, pa.N2, pa.Mi1, pa.Mi2, pa.L2};    for (int dd = 0; dd < labelSet.length; dd++) {      labelSet[dd].setText(labelNames[dd] + str(paramSet[dd]));      scrollSet[dd].setValue((int) (paramSet[dd] * multiplier[dd]));    }    scrollbarTime.setValue((int) pa.currentTime);    plotPanel.setDirty();    treePanel.repaint();    checkboxGperNuc.setState(false);    plotAxesPanel.repaint();  }  public void setCase(int whichCase) {    setRunFlagFalse();    checkboxStraight.setState(false);    checkboxAnimatedPlot.setState(false);    while (treeBusy || plotBusy);    pa.txt = definitions[whichCase];    se.txtToNumbers(pa);    //  Demo to intitialize the Applet with parameters from HTML tags:    //if (whichCase == 3) {    //		pa.TD1 = parTD1;}    //    if (whichCase < 5)//cases.select(whichCase);27.12.2010    {      cases.select(0);//cases.select(whichCase);27.12.2010    }    updateControls();    runButton.setLabel("Run");    setRunFlagFalse();    treePanel.setDirty();    plotPanel.setDirty();    boolean withEclipse = ((pa.L2 != 0) || (whichCase == 4));    scrollbarL2.setVisible(withEclipse);    labelL2.setVisible(withEclipse);  }//    public void toCaseZero() {//        setRunFlagFalse();////        checkboxStraight.setState(false);//        checkboxAnimatedPlot.setState(false);//        while (treeBusy || plotBusy);//        cases.select(0);//        runButton.setLabel("Run");//        setRunFlagFalse();////    }  public void scrollbarC1AdjustmentValueChanged() {    labelC1.setText(" C1=  " + str(scrollbarC1.getValue()));    pa.C1 = scrollbarC1.getValue();    plotPanel.setDirty(true);  }  public void scrollbarD1AdjustmentValueChanged() {    labelD1.setText(" D1=  " + str(scrollbarD1.getValue()));    pa.D1 = scrollbarD1.getValue();    plotPanel.setDirty(true);  }  public void scrollbarN1AdjustmentValueChanged() {    pa.N1 = scrollbarN1.getValue();    if (pa.N1 > (pa.D1 - 0.1)) {      pa.N1 = pa.D1 - 0.1;      scrollbarN1.setValue((int) pa.N1);    }    labelN1.setText(" N1= " + str(scrollbarN1.getValue()));    plotPanel.setDirty(true);  }  public void scrollbarTD2AdjustmentValueChanged() {    labelTD2.setText(" TD2= " + str(scrollbarTD2.getValue()));    pa.TD2 = scrollbarTD2.getValue();    plotPanel.setDirty(true);  }  public void scrollbar5AdjustmentValueChanged() {    labelC2.setText(" C2= " + str(scrollbarC2.getValue()));    pa.C2 = scrollbarC2.getValue();    plotPanel.setDirty(true);  }  public void scrollbarD2AdjustmentValueChanged() {    pa.D2 = scrollbarD2.getValue();    labelD2.setText(" D2 = " + str(scrollbarD2.getValue()));    plotPanel.setDirty(true);  }  public void scrollbarN2AdjustmentValueChanged() {    pa.N2 = scrollbarN2.getValue();    if (pa.N2 > pa.D2) {      pa.N2 = pa.D2;      scrollbarN2.setValue((int) pa.N2);    }    labelN2.setText(" N2 = " + str(scrollbarN2.getValue()));    plotPanel.setDirty(true);  }  public void scrollbarMi1AdjustmentValueChanged() {    pa.Mi1 = scrollbarMi1.getValue();    pa.Mi1 /= MiGrain;    labelMi1.setText(" Mi1= " + str(pa.Mi1));    plotPanel.setDirty(true);  }  public void scrollbarMi2AdjustmentValueChanged() {    pa.Mi2 = 1.0 / MiGrain * scrollbarMi2.getValue();    labelMi2.setText(" Mi2= " + str(pa.Mi2));    plotPanel.setDirty(true);  }  public void scrollbarL2AdjustmentValueChanged() {    pa.L2 = 0.01 * scrollbarL2.getValue();    pa.L1 = pa.L2;    labelL2.setText(" E/C= " + str(pa.L2));    plotPanel.setDirty(true);  }  public void scrollbarViewAngleAdjustmentValueChanged() {    checkboxStraight.setState(false);    ASPECT = 0.01 * scrollbarViewAngle.getValue();    if (ASPECT > 1) {      ASPECT = 1;    }    treePanel.setDirty();  }  public void scrollbarTimeAdjustmentValueChanged() {    pa.currentTime = scrollbarTime.getValue() + 0.00022;// dirty trick;;    treePanel.setDirty();    plotPanel.drawPlotAndTime();  }  public void DoPrintEventChain() {    this.printEventChain();  }  public class CalcCycle {    double thisTd, thisC, thisD, thisN;    public CalcCycle() {    }    void switchSettings(double time) {      double transition = preCycles * pa.TD1;      if ((time < transition) || (time == 0) || (time > 240)) {        thisTd = pa.TD1;        thisC = pa.C1;        thisD = pa.D1;        thisN = pa.N1;      } else if (time >= transition) {        thisTd = pa.TD2;        thisC = pa.C2;        thisD = pa.D2;        thisN = pa.N2;      }    }    public void add_Event(double time, int type) {      int dest = maxRow;      while ((timeArr[dest] > (0.0001 * type + time)) && (dest > 1)) {        dest--;      }      int shift = maxRow - dest; //shuffle future events up      dest++;      for (int jj = maxRow + 1; jj > maxRow - shift + 1; jj--) {        timeArr[jj] = timeArr[jj - 1];        typeArr[jj] = typeArr[jj - 1];      }      timeArr[dest] = time;      typeArr[dest] = type;      maxRow++;    }// calculate the time of any period which may be composed of different// parts before and after transition    public double calcFinishTime(double tim, double transition, double before, double after) {      double leftFraction = (transition - tim) / before;      if (leftFraction < 0) {        leftFraction = 0;      }      if (leftFraction > 1) {        leftFraction = 1;      }      return tim + leftFraction * before + (1 - leftFraction) * after;    }    public double calcMass(double time) {      double transition = preCycles * pa.TD1;      double slope = 1 / pa.TD1;      double Mi1Log = 1 + Math.log(pa.Mi1) / Math.log(2);      double startmass = minusCycles /*               * + 1               */ + Mi1Log + slope * (pa.C1 + pa.D1 - pa.TD1);      if (time < transition) {        return (startmass + time / pa.TD1);      } else {        return startmass + transition / pa.TD1 + (time - transition) / pa.TD2;      }    }    public double calcCellMass(double time) {      if (time <= 0) {        return massCellArr[1];      }      int row = 1;      while (time > timeArr[row]) {        row++;      }      double m1 = massCellArr[row - 1];      double stepM = massCellArr[row] - m1;      double t1 = timeArr[row - 1];      double stepT = timeArr[row] - t1;      double dt = time - t1;      return m1 + dt / stepT * stepM;    }    public void checkNbelowD() {      if (pa.N1 > (pa.D1 - 0.1)) {        pa.N1 = pa.D1 - 0.1;        scrollbarN1.setValue((int) pa.D1);        //propagateScrollPosition(scrollbarN1);        labelN1.setText(" N1 = " + str(pa.D1));      }      if (pa.N2 > (pa.D2 - 0.1)) {        pa.N2 = pa.D2 - 0.1;        scrollbarN2.setValue((int) pa.D2);        //propagateScrollPosition(scrollbarN2);        labelN2.setText(" N2 = " + str(pa.D2));      }    }    public double blockedUntil(double initTime, double transition, double LL1, double LL2) {      double beforeFraction, afterFraction = 0, deltaT = 0, blUntil;      beforeFraction = (transition - initTime) / pa.C1;      if (beforeFraction < 0) {        beforeFraction = 0;      }      if (beforeFraction > LL1) {        beforeFraction = LL1;        deltaT = LL1 * pa.C1;      } else {        afterFraction = LL2 - beforeFraction;        if (afterFraction < 0) {          afterFraction = 0;        }        deltaT = beforeFraction * pa.C1 + afterFraction * pa.C2;      }      blUntil = initTime + deltaT;      return blUntil;    }    public void buildEventChain() {      int row = 1;      double Mi1Log = 1 + Math.log(pa.Mi1) / Math.log(2);      double Mi2Log = 1 + Math.log(pa.Mi2) / Math.log(2);      double time, mass, transition,              Mi, deltaMi = Mi2Log - Mi1Log,              blocked = -999.9, ttt;      checkNbelowD();      maxRow = 0;      time = -minusCycles * pa.TD1;      transition = preCycles * pa.TD1;      Mi = Mi1Log;      mass = Mi1Log;      time = time - (pa.C1 + pa.D1);      while (true) { //add inits before transition        ttt = time;        if (ttt < blocked) {          ttt = blocked;        }        add_Event(ttt, initID);        blocked = blockedUntil(ttt, transition, pa.L1, pa.L2);        time += pa.TD1;        Mi += 1;        mass += 1;        if (time > transition) {          mass -= (time - transition) / pa.TD1;          time = transition;          Mi += deltaMi;          add_Event(time, transID);          break;        }      }      while (mass >= Mi) {//possibly multiple origins at transition        ttt = time;        if (ttt < blocked) {          ttt = blocked;        }        add_Event(ttt, initID);        blocked = blockedUntil(ttt, transition, pa.L1, pa.L2);        Mi += 1;      }      time += (Mi - mass) * pa.TD2;      while (true) {        ttt = time;        if (ttt < blocked) {          ttt = blocked;        }        add_Event(ttt, initID);        blocked = blockedUntil(ttt, transition, pa.L1, pa.L2);        time += pa.TD2;        Mi += 1;        if (time > 999) {          break;        }      }    }    public void enterDivisions() {      int typ, row = 0, mxr;      double Da1 = pa.N1;      double Db1 = pa.D1 - pa.N1;      double Da2 = pa.N2;      double Db2 = pa.D2 - pa.N2;      double time = -999, transition = preCycles * pa.TD1;      while (row < (maxRow - 2)) {        row++;        time = timeArr[row];        typ = typeArr[row];        if (typ == initID) {          time = calcFinishTime(time, transition, pa.C1, pa.C2);          add_Event(time, cDoneID);          time = calcFinishTime(time, transition, Da1, Da2);          add_Event(time, nucSepID);          add_Event(time, nucSepID2);          time = calcFinishTime(time, transition, Db1, Db2);          add_Event(time - 0.0006, divideID);// my dirty trick- no          add_Event(time - 0.0003, divideID2);        }      }    }    public void enterMass() {      double time, mm, factor = 0;      int type;      for (int row = 1; row < maxRow; row++) {        time = timeArr[row];        type = typeArr[row];        if (type == divideID2) {          factor++;        }        mm = calcMass(time);        massAllArr[row] = mm;        massCellArr[row] = mm - factor;      }    }    public void logEvents() {      if (!testFlag2) {        return;      }      String id;      System.out.println("TD1= " + str82(pa.TD1) + "	 TD2= " + str82(pa.TD2));      System.out.println("pa.D1 = " + str82(pa.D1) + "	pa.D2 = " + str82(pa.D2));      System.out.println("pa.C1 = " + str82(pa.C1) + "	pa.C2 = " + str82(pa.C2));      System.out.println("pa.D1 = " + str82(pa.D1) + "	pa.D2 = " + str82(pa.D2));      System.out.println("pa.N1 = " + str82(pa.N1) + "	pa.N2 = " + str82(pa.N2));      System.out.println("M1 = " + str82(pa.Mi1) + "	 M2 = " + str82(pa.Mi2));      System.out.println("time	   = " + str82(pa.currentTime));      System.out.println("transition = " + str82(preCycles * pa.TD1));      System.out.println("");      System.out.println("row     forktime   seg");      for (int jj = forks; jj >= 0; jj--) {        System.out.println(str80(jj) + str82(forkInitArr[jj]) //+ str82(forkAgeArr[jj])                + str82(forkSegArr[jj]));      }      System.out.println(" ");      System.out.println("");      System.out.println("row     path   seg");      for (int jj = 1; jj <= tu.n_vPtr; jj++) {        System.out.println(str80(jj) + str82(tu.n_Path[jj]) + str82(tu.n_Pen[jj]));      }      System.out.println("chromRad= " + str82(chromRad) + "   chromRad*2= " + str82(chromRad * 2));      System.out.println("     row    time     ID    massAll mssCell     Genome");      for (int jj = 1; jj <= 80; jj++) {        id = "			";        if (typeArr[jj] == initID) {          id = "  + Init  ";        }        if (typeArr[jj] == divideID) {          id = "  - Div   ";        }        if (typeArr[jj] == nullID) {          id = "  Start   ";        }        if (typeArr[jj] == transID) {          id = "--- Trans ";        }        if (typeArr[jj] == cDoneID) {          id = "   CDone  ";        }        if (typeArr[jj] == nucSepID) {          id = "   NucSep ";        }        if (typeArr[jj] == nucSepID2) {          id = "   Ns2    ";        }        if (typeArr[jj] == divideID2) {          id = "   div2   ";        }        System.out.println(str80(jj) + str82(timeArr[jj]) + id + str82(massAllArr[jj]) + str82(massCellArr[jj]) + str82(genomeArr[jj]) + newline);      }      /*       * 26.9.2006       */    }    public void calcLevels() {      int typ, lev = 1;  //17.11.200      for (int row = 1; row < (maxRow - 1); row++) {        typ = typeArr[row];        if (typ == initID) {          lev++;        }        if (typ == divideID) {          lev--;        }        levelArr[row] = lev;      }    }//=== sort event chain    public void sortEventChain() {      int typ;      double tim, mass;      for (int rowA = 1; rowA < (maxRow - 1); rowA++) {        for (int rowB = rowA + 1; rowB <= maxRow; rowB++) {          if ((timeArr[rowA] + 0.00001 * typeArr[rowA]) > (timeArr[rowB] + 0.00001 * typeArr[rowB])) {            tim = timeArr[rowA];            timeArr[rowA] = timeArr[rowB];            timeArr[rowB] = tim;            typ = typeArr[rowA];            typeArr[rowA] = typeArr[rowB];            typeArr[rowB] = typ;            mass = massAllArr[rowA];            massAllArr[rowA] = massAllArr[rowB];            massAllArr[rowB] = mass;            mass = massCellArr[rowA];            massCellArr[rowA] = massCellArr[rowB];            massCellArr[rowB] = mass;          }        }      }    }    public void genomeFromChain() {      /*       * Calculating DNA content: each fork point F represents a DNA production stream of 1. How to       * count points? - Init	event doubles left ends - CDone	event halfs doubles right ends -       * NucSep event doubles number of nucs - Divide event divides leftEnds, rightEnds and nNucs by       * 2 - DNA production is ~(leftEnds - rightEnds) - slope is DNAproduction/C       */      int typ = 0;      int leftEnds = 1, rightEnds = 1, leftEndsAll = 1, rightEndsAll = 1, nNucs = 1;      double lastTim = noValue, tim = 0, genome = 0, genomeAll = 0, slope = 0;      genome = 1;//is this the salvation? Well, if case <> reset, we should calculate this from the parameters      genomeAll = 1;      thisC = pa.C1;      for (int row = 1; row < maxRow; row++) {        genomeArr[row] = noValue;        genPerNucArr[row] = noValue;        leftEndsArr[row] = noValue;        rightEndsArr[row] = noValue;        leftEndsAllArr[row] = noValue;        rightEndsAllArr[row] = noValue;        nNucsArr[row] = noValue;        typ = typeArr[row];        tim = timeArr[row];        if (lastTim == noValue) {          lastTim = tim;        }        if (typ == transID) {          thisC = pa.C2;        }        slope = leftEnds - rightEnds;        double dGenome = slope * (tim - lastTim) / thisC;        genome = genome + dGenome;        genomeAll = genomeAll + dGenome;        genomeArr[row] = genome;        genPerNucArr[row] = genome / nNucs;        lastTim = tim;        if (typ == divideID) {          leftEnds /= 2;          rightEnds /= 2;          leftEndsArr[row] = leftEnds;          rightEndsArr[row] = rightEnds;          nNucsArr[row] = nNucs;          genome /= 2;          nNucs /= 2;        }        if (typ == cDoneID) {          rightEnds *= 2;          rightEndsAll *= 2;          rightEndsArr[row] = rightEnds;          rightEndsAllArr[row] = rightEndsAll;        }        if (typ == initID) {          leftEnds *= 2;          leftEndsAll *= 2;          leftEndsArr[row] = leftEnds;          leftEndsAllArr[row] = leftEndsAll;        }        if (typ == nucSepID) {          nNucsArr[row] = nNucs;          nNucs *= 2;        }        if (typ == nucSepID2) {          nNucsArr[row] = nNucs;        }        if (typ == divideID2) {          nNucsArr[row] = nNucs;        }      }    }    public void lineFromChain() {      int typ, row, rowB, rowC;      double tim, mass, genom;      massPolyLineX[0] = 0;      massPolyLineY[0] = 120 - 0;      rowB = 0;      for (row = 1; row < maxRow; row++) {        typ = typeArr[row];        tim = timeArr[row];        if (tim > -1) {          mass = massCellArr[row];          if ((typ == divideID) || (typ == nullID) || (typ == divideID) || (typ == divideID2) || (typ == transID)) {            rowB++;            massPolyLineX[rowB] = (int) tim;            massPolyLineY[rowB] = (int) (plotPanelHeight - octHeight * 2 - octHeight * mass);          }        }      }      lastPoint1 = rowB;      rowB = -1;      rowC = 0;      for (row = 1; row < maxRow; row++) {        typ = typeArr[row];        tim = timeArr[row];        if (tim >= -100) {//4.10.2006          genom = genomeArr[row];          if ((typ == initID) || (typ == divideID) || (typ == divideID2) || (typ == cDoneID)) {            rowB++;            dnaPolyLineX[rowB] = (int) Math.round(tim);            dnaPolyLineY[rowB] = (int) (plotPanelHeight - octHeight * 2 + octHeight - octHeight * genom);            double massLog = massCellArr[row];            mass = Math.pow(2, massCellArr[row]);            double cDNA = genom / mass;            int yPos = (int) (plotPanelHeight - octHeight * cDNA * 4 - octHeight * 2);//1.10.2006 was * 2            if ((typ == initID) || (typ == divideID2) || (typ == divideID) || (typ == cDoneID)) {              rowC++;              auxMass[rowC] = massLog;              auxGenom[rowC] = genom;              auxTime[rowC] = tim;            }          }        }      }      lastPoint2 = rowB;      lastPoint3 = rowC;      interpolatecDNA();      if (dnaPolyLineX[1] == 0) {        dnaPolyLineY[0] = dnaPolyLineY[1];      }    }    void interpolatecDNA() {      double thisTime, thisMass, thisGenome, nextTime, nextMass, nextGenome,              genomePoint, massPoint, cDNAPoint, timePoint, theMass;      int rowD = 0;      timePoint = auxTime[0];      for (int cc = 0; cc <= lastPoint3; cc++) {        thisTime = auxTime[cc];        thisMass = auxMass[cc];        thisGenome = auxGenom[cc];        nextTime = auxTime[cc + 1];        nextMass = auxMass[cc + 1];        nextGenome = auxGenom[cc + 1];        while ((timePoint < nextTime) && (timePoint <= k480)) {          genomePoint = thisGenome + (nextGenome - thisGenome) * (timePoint - thisTime) / (nextTime - thisTime);          theMass = thisMass + (nextMass - thisMass) * (timePoint - thisTime) / (nextTime - thisTime);          massPoint = Math.pow(2, theMass);          cDNAPoint = genomePoint / massPoint;          cDNAPolyLineX[rowD] = (int) timePoint;          cDNAPolyLineY[rowD] = (int) (plotPanelHeight - octHeight * 2 - octHeight * cDNAPoint * 4);//1.10.2006 was * 2          timePoint++;          rowD++;        }      }      lastPoint3 = rowD;    }    public void calcCurrentMass() {      double factor, mm;      double tt = 0;      int tmp;      currentLeftEnds = 1;      currentRightEnds = 1;      currentnNucs = 1;      for (int row = 1; tt <= pa.currentTime; row++) {        tt = timeArr[row];        if (tt <= pa.currentTime) {          currentLevel = levelArr[row];        }        if (tt <= pa.currentTime) {          currentLevel = levelArr[row];          tmp = leftEndsArr[row];          if (tmp != noValue) {            currentLeftEnds = tmp;          }          tmp = rightEndsArr[row];          if (tmp != noValue) {            currentRightEnds = tmp;          }          tmp = nNucsArr[row];          if (tmp != noValue) {            currentnNucs = tmp;          }        }      }      currentMass = noValue;      for (int row = 1; currentMass == noValue; row++) {        mm = massCellArr[row];        tt = timeArr[row];        switchSettings(pa.currentTime);        if ((mm != noValue) && (tt >= pa.currentTime) && (currentMass == noValue)) {          factor = (double) (pa.currentTime - tt) / thisTd;          currentMass = mm + factor;          currentMass2 = Math.exp(Math.log(2) * currentMass);        }      }    }    public void CandD() {      int row;      double cycleStop = 0;      int typ = 0;      final int four = 4;      double tim, futur = 0;      double x0 = 0, y1 = plotPanelHeight - 2 + four * minusCycles;      switchSettings(0);      CDlines = 0;      //for(row = 1; (typ != 0) || (row <6); row++) {      double cIsDone, transition = preCycles * pa.TD1;      for (row = 1; (row < maxRow); row++) {        typ = typeArr[row];        futur = timeArr[row];        if (typ == initID) {          x0 = futur;          if (x0 > cycleStop) {            CDlines++;            CDx1[CDlines] = (int) cycleStop;            CDx2[CDlines] = (int) x0;            CDy1[CDlines] = (int) y1;            CDy2[CDlines] = (int) y1;            CDcolor[CDlines] = Color.green; //green          }          CDlines++;          CDx1[CDlines] = (int) x0;          futur = calcFinishTime(futur, transition, pa.C1, pa.C2);          x0 = (int) (futur);          CDx2[CDlines] = (int) x0;          CDy1[CDlines] = (int) y1;          CDy2[CDlines] = (int) y1;          CDcolor[CDlines] = Color.red; //red          CDlines++;          CDx1[CDlines] = (int) x0;          cIsDone = futur;          futur = calcFinishTime(futur, transition, pa.D1, pa.D2);          x0 = (int) (futur);          CDx2[CDlines] = (int) x0;          CDy1[CDlines] = (int) y1;          CDy2[CDlines] = (int) y1;          CDcolor[CDlines] = Color.blue; //blue          futur = calcFinishTime(cIsDone, transition, pa.N1, pa.N2);          CDlines++;          CDx1[CDlines] = (int) (futur);          CDx2[CDlines] = CDx1[CDlines];          CDy1[CDlines] = (int) y1;          CDy2[CDlines] = (int) y1;          CDcolor[CDlines] = Color.white;	//white          y1 -= four;          cycleStop = x0;        }      }    }    public void push(double x1, double y1, double x2, double y2, int col) {      /*       * put line segments with colors into the array, for a stupid plotter       *       * }       */      nlines++;      xx1[nlines] = (int) x1;      yy1[nlines] = (int) y1;      xx2[nlines] = (int) x2;      yy2[nlines] = (int) y2;      if (col == 1) {        ccc[nlines] = Color.red;      }      if (col == 2) {        ccc[nlines] = Color.green;      }      if (col == 3) {        ccc[nlines] = Color.blue;      }      if (col == 4) {        ccc[nlines] = Color.yellow;      }      if (col == 5) {        ccc[nlines] = Color.cyan;      }      if (col == 6) {        ccc[nlines] = Color.magenta;      }      if (col == 64) {        ccc[nlines] = Color.lightGray;      }      if (col == 128) {        ccc[nlines] = Color.gray;      }    }    public void drawSubTree(double x, double y, double tux, double tuy, double angle, double path, int level, int dir) {      double start, stop, dx, dy = 0, newX, newY, newtux, newtuy, newAngle;      start = forkSegArr[level];      stop = forkSegArr[level - 1];      dx = -stop + start;      newX = x + dx;      double max = forkSegArr[forks];      //straight part      double scaleDown = 1;      double expectHeight = Math.pow(2.0, max * 0.04);      if (expectHeight > (treeImgHeight * 0.9)) {        scaleDown = (treePanelHeight * 0.4) / expectHeight;      }      if (level != forks) {        dy = (int) scaleDown * (Math.pow(2.0, start * 0.04));      }      if (dy < 1) {        dy = 1;      }      dy *= dir;      y = (int) y;      newY = y + dy;      if (yBottom < newY) {        yBottom = (int) newY;      }      if (yTop > newY) {        yTop = (int) newY;      }      if (level == forks) {        treeYCenter = (int) newY;      }      if (start > kk100) {        start = kk100;      }      if (stop > kk100) {        stop = kk100;      }      currentGenome += (start - stop) / kk100 * copies;      //flower part      tu.turtlePen = 0;      tu.turtlePath = path;      tu.turtleSet(tux, tuy, angle);      tu.turtlePen = 1;      //if (level != forks)      double factor = 0.93 * treeImgHeight / 100;      if (forkSegArr[level] < kk100) {        tu.turtleArc(dir * dx / 2 * factor, 50 * 2, 0);      } else {        for (int mm = 0; mm < 33; mm++) {          tu.turtleLine(0, dx / 33 * factor);        }      }      path = tu.turtlePath;      newtux = tu.turtleX;      newtuy = tu.turtleY;      newAngle = tu.turtleAngle;      push(x, y, x, newY, 6);      push(x, newY, newX, newY, 3);      level--;      if (level > 0) {        drawSubTree(newX, newY, newtux, newtuy, newAngle, path, level, 1);        drawSubTree(newX, newY, newtux, newtuy, newAngle, path, level, -1);      }    }    public void wholeTree() {      copies = 1;      while (forkSegArr[forks - 1] >= kk100) {//19.8.2006        forks--;        forkSegArr[forks] = kk100;        copies *= 2;      }      //n_print("copies calculated by wholeTree = " + copies);      int x = 0, y = 0;      double angle = 90,              tux = treeImgWidth / 2,              tuy = treeImgHeight - 7,              path = 0;      nlines = 0;      yBottom = 0;      yTop = 999;      y = (int) treeImgHeight / 2;      currentGenome = 0;      tu.turtleReset(tux, tuy, angle);      if (forks <= 6) //protect overflow      {        drawSubTree(x, y, tux, tuy, angle, path, forks, 1);      }      double rr, ll, k112 = forkSegArr[forks];      double thisFactor = treeImgWidth / k112;      for (int jj = 1; jj <= nlines; jj++) {        rr = xx1[jj];        ll = xx2[jj];        xx1[jj] = -(int) (thisFactor * (rr - k112));        xx2[jj] = -(int) (thisFactor * (ll - k112));      }    }    public double calcDnaSegment(double t1, double t2, double transition) {      // returns > 100% if t2 is after termination      if (t2 < transition) {        return (t2 - t1) / pa.C1;      }      if (t1 > transition) {        return (t2 - t1) / pa.C2;      } else {        return (transition - t1) / pa.C1 + (t2 - transition) / pa.C2;      }    }    public void prepareTree() {      //prepare arrays for recursive stuff      double timeAtInit, age = 0, seg = 0;      double transition = preCycles * pa.TD1;      double thisCDone, thisDDone;      forks = 0;      for (int row = maxRow; row > 1; row--) {        if ((typeArr[row] == initID) && (timeArr[row] <= pa.currentTime)) {          timeAtInit = timeArr[row];          thisCDone = calcFinishTime(timeAtInit, transition, pa.C1, pa.C2);          thisDDone = calcFinishTime(thisCDone, transition, pa.D1, pa.D2);          if (pa.currentTime <= thisDDone) {            age = pa.currentTime - timeAtInit;            seg = 100 * calcDnaSegment(timeAtInit, pa.currentTime, transition);            forkInitArr[++forks] = timeAtInit;            forkSegArr[forks] = seg;          }        }      }      forkInitArr[++forks] = -999;      if (seg < 100) {        seg = 100;      }      forkSegArr[forks] = seg;    }    public void calcTransitions() {      double TT = 0, previousTT = noValue, transition = pa.TD1 * preCycles;      double MM = noValue, previousMM = noValue;      boolean equalMass, equalTd;      stopTrans = noValue;      startTrans = transition;      double lm = -99, rm = -99;      for (int row = 1; row < maxRow; row++) {        if (typeArr[row] == transID) {          lm = MM;        }        if (typeArr[row] == divideID) {          MM = massCellArr[row];          TT = timeArr[row];          equalMass = (Math.abs(MM - previousMM) < 0.001);          //equalMass = equalMass && (Math.abs (MM - prevprevMM) < 0.001);          equalTd = (Math.abs(TT - previousTT - pa.TD2) < 0.001);          //equalTd = equalTd && (Math.abs (TT - prevprevTT -2*pa.TD2) < 0.001);          if ((previousTT > transition) && equalMass && equalTd && (stopTrans == noValue)) {            //stopTrans = prevprevTT;            stopTrans = previousTT;            rm = MM;          }          //prevprevTT = previousTT;          //prevprevMM = previousMM;          previousTT = TT;          previousMM = MM;        }      }      if (pa.TD1 == pa.TD2 && pa.C1 == pa.C2 && pa.D1 == pa.D2 && pa.Mi1 == pa.Mi2) {        startTrans = stopTrans = 0;      } else if (stopTrans == noValue) {        stopTrans = xStop - xStart;      }      leftAvgMass = Math.log(2) * Math.pow(2, lm);      rightAvgMass = Math.log(2) * Math.pow(2, rm);    }    //public void setLabels() {}    public void showNumbers1() {      String ss = "Average mass\rbefore and after \rtransition:\r";      ss = ss + newline + "Before = " + str(leftAvgMass);      ss = ss + newline + "After  = " + str(rightAvgMass);      textArea1.setText(ss);      //textArea1.setText("row   time type   level mass\r");//            textArea1.setText("Average mass\rbefore and after \rtransition:\r");//            textArea1.a.appendText(newline + "Before = " + str(leftAvgMass));//            textArea1.appendText(newline + "After  = " + str(rightAvgMass));    }    public void showNumbers2() {      numbersArea.setForeground(new java.awt.Color(0, 0, 0));      numbersArea.setBackground(new java.awt.Color(200, 222, 233)); //30.8.2006      String ss = pa.name;      ss = ss + (newline + newline + " Time    = " + str(pa.currentTime + xStart));      double mm = calcCellMass(pa.currentTime);      mm = (Math.pow(2, mm));      ss = ss + (newline + " Mass    = " + str(mm));      ss = ss + (newline + " DNA     = " + str(currentGenome));      ss = ss + (newline + " DNA/Nuc = " + str(currentGenome / currentnNucs));      ss = ss + (newline + " DNA/Mass= " + str(currentGenome / mm));      ss = ss + (newline + " oriCs   = " + str(currentLeftEnds));      ss = ss + (newline + " terCs   = " + str(currentRightEnds));      ss = ss + (newline + " nNucs   = " + str(currentnNucs));      if (testFlag1) {        ss = ss + (newline + " AbsTime = " + str(pa.currentTime));      }      numbersArea.setText(ss);    }  }  public class TreePanel extends Panel {    public TreePanel() {    }    boolean treeDirty = true;    public void setDirty() {      treeDirty = true;    }    public void paint(Graphics g) {      setDirty();    }    public void treePaint(Graphics g) {      treeBusy = true;      myCalc.prepareTree();      myCalc.wholeTree();      myCalc.calcCurrentMass();      treeOffscreenPort.setColor(new Color(255, 255, 160));      treeOffscreenPort.fillRoundRect(0, 0, treeImgWidth, treeImgHeight, 16, 16);      if (checkboxStraight.getState()) {        treeOffscreenPort.setColor(new Color(210, 210, 210));        int k10 = 10;        for (int xgrid = 0; xgrid < k10; xgrid++) {          int thisx = (int) (treeImgWidth / k10 * xgrid);          treeOffscreenPort.drawLine(thisx, 0, thisx, treeImgHeight - 1);          if (xgrid == (k10 / 2)) {            treeOffscreenPort.drawLine(thisx + 1, 0, thisx + 1, treeImgHeight - 1);          }        }        for (int x1, x2, y1, y2, ww, row = 1; row <= nlines; row++) {          x1 = xx1[row];          x2 = xx2[row];          y1 = yy1[row];          y2 = yy2[row];          treeOffscreenPort.setColor(ccc[row]);          if (ccc[row] == Color.blue) {          }          treeOffscreenPort.drawLine(x1, y1, x2, y2);        }        treeOffscreenPort.setColor(Color.black);      } else {//do flowers        chromRad = tu.turtlePath / 2; //chromosome radius        Color myGray = new Color(156, 156, 156);        double tux = treeImgWidth / 2;        double tuy = treeImgHeight - 7;        double ASPECT2 = Math.sqrt(1 - (ASPECT * ASPECT));        for (int kk = 1; kk < (tu.n_vPtr); kk++) {          double yyy0 = chromRad - tu.n_Path[kk];          double yyy1 = chromRad - tu.n_Path[kk + 1];          double xxx0 = ASPECT * Math.sqrt(chromRad * chromRad - yyy0 * yyy0);          double xxx1 = ASPECT * Math.sqrt(chromRad * chromRad - yyy1 * yyy1);          double xxx1Full = Math.sqrt(chromRad * chromRad - yyy1 * yyy1);          double xxx0Full = Math.sqrt(chromRad * chromRad - yyy0 * yyy0);          double px1, px2, py1, py2;          px1 = tux + ASPECT2 * (tu.n_VertX[kk] - tux);          px2 = tux + ASPECT2 * (tu.n_VertX[kk + 1] - tux);          py1 = tu.n_VertY[kk] + yyy0;          py2 = tu.n_VertY[kk + 1] + yyy0;          if ((tu.n_Pen[kk + 1] == 0) && (xxx0Full > 0.001)) {            treeOffscreenPort.setColor(myGray);            treeOffscreenPort.fillOval(round(px1 - xxx0 - 2), round(tu.n_VertY[kk] - 2), 4, 4);            treeOffscreenPort.setColor(Color.black);            treeOffscreenPort.fillOval(round(px1 + xxx0 - 2), round(tu.n_VertY[kk] - 2), 4, 4);          }          if ((tu.n_Pen[kk + 1] != 0)) {            treeOffscreenPort.setColor(myGray);            treeOffscreenPort.drawLine(round(px1 - xxx0), round(tu.n_VertY[kk]), round(px2 - xxx1), round(tu.n_VertY[kk + 1]));            treeOffscreenPort.setColor(Color.black);            treeOffscreenPort.drawLine(round(px1 + xxx0), round(tu.n_VertY[kk]), round(px2 + xxx1), round(tu.n_VertY[kk + 1]));          }          //if (xxx1 < 0.0001){          if (kk == 1) {            if (tu.n_Path[kk] < 2) {              treeOffscreenPort.setColor(Color.blue);              treeOffscreenPort.fillOval(round(tu.n_VertX[kk + 1] - 2.5), round(tu.n_VertY[kk + 1] - 4), 5, 5);            }          } else {            if (xxx1Full < 0.0001) {              treeOffscreenPort.setColor(Color.red);              treeOffscreenPort.fillOval(round(px2 - 2.5), round(tu.n_VertY[kk + 1] - 1), 5, 5);            }          }          treeOffscreenPort.setColor(Color.black);        }        treeOffscreenPort.setColor(Color.blue);        treeOffscreenPort.fillOval(terPosX - 2, terPosY - 4, 5, 5);        treeOffscreenPort.setColor(Color.black);      }      treeOffscreenPort.drawRoundRect(0, 0, treeImgWidth - 1, treeImgHeight - 1, 16, 16);      treePanel.setVisible(true);      treePanelOffscreenPort.clearRect(0, 0, treePanelWidth, treePanelHeight);      int toDraw = copies;      if (toDraw > 4) {        toDraw = 4;      }      treePanelOffscreenPort.setFont(courier10);      for (int qq = toDraw - 1; qq >= 0; qq--) {        int offx = (/*                 * 4-                 */qq) * copyOffsetX;        int offy = qq * copyOffsetY;        treePanelOffscreenPort.drawImage(treeOffscreenImg, offx, offy, null);        String copyLabel = "" + (qq + 1);        if ((qq == 3) && (copies > 4)) {          copyLabel = "..." + copies;        }        treePanelOffscreenPort.drawString(copyLabel, offx + 10, treeImgHeight - 7 + offy);      }      //if (toDraw != copies) treePanelOffscreenPort.drawString("Total copies = " + copies,  treePanelWidth/3, treePanelHeight-2  );      g.drawImage(treePanelOffscreenImg, 0, 0, null);      treeDirty = false;      treePanel.setVisible(true);      treeBusy = false;      wallPanel.setDirty();    }  }  public class plotAxesPanel extends Panel {    boolean numDirty = true;    public void setDirty() {      numDirty = true;    }    public void invalidate() {      super.invalidate();    }    public void update(Graphics g) {      paint(g);    }    public void paint(Graphics g) {      setDirty();    }    public void numPaint(Graphics g) {      String ss;      int nn;      g.setFont(courier9);      g.clearRect(0, 0, 1000, 1000);      for (int expo = 0; expo <= 6; expo++) {//1.10.2006        nn = (int) Math.pow(2, expo);        ss = "" + nn;        if (nn < 10) {          ss = " " + ss;        }        if (expo <= 5) {          g.setColor(Color.black);          if (checkboxMass.getState()) {            g.drawString(ss, 16, 164 - expo * octHeight);          }          g.setColor(Color.magenta);          ss = "" + (expo + 1);          if (checkboxGenome.getState()) {            g.drawString(ss, 516, 164 - expo * octHeight);          }        }        if (checkboxcDNA.getState() && (expo % 2 == 0) /*                 * && (expo > 0)                 */) {          g.setColor(new Color(0, 128, 0));          ss = "" + (((double) expo) / 4);//1.10.2006          g.drawString(ss, 516 + kk50, 164 - expo * octHeight /*                   * + 2 * octHeight                   */);        }      }      g.setColor(Color.black);      for (int minutes = -180; minutes < xStop; minutes += 60) {        ss = "" + minutes;        int offset = 34 - ss.length() * 3;        int xx = minutes - xStart + offset;        if ((xx > 10) && (xx < (xStop - xStart - 20))) {          g.drawString(ss, xx, 222);        }      }      g.drawString("time[min]", 490, 222);      if (checkboxMass.getState()) {        g.drawImage(imMassLabel, 2, 40, Color.white, this);      }      if (checkboxGenome.getState()) {        g.drawImage(imGenomeLabel, 524, 40 + 9, Color.white, this);      }      if (checkboxcDNA.getState()) {        g.drawImage(imcDNALabel, 524 + kk50 + 14, 40 + 56 + 3, Color.white, this);      }      numDirty = false;    }  }  public class WallPanel extends Panel {    public boolean wallDirty = true;    public WallPanel() {    }    public void setDirty() {      wallDirty = true;    }    public void paint(Graphics wallPort) {      setDirty();    }    public void wallPaint(Graphics wallPort) {      wallOffscreenPort.setColor(new Color(220, 220, 220));      wallOffscreenPort.clearRect(0, 0, wallPanelWidth, wallPanelHeight);      wallOffscreenPort.fillRect(0, 0, wallPanelWidth - 1, wallPanelHeight - 1);      calcWall(wallOffscreenPort);      wallPort.drawImage(wallOffscreenImg, 0, 0, null);      wallDirty = false;    }    public void calcWall(Graphics wallPort) {      text3 = "";      double thisTime = pa.currentTime;      if ((thisTime <= stopTrans) && (thisTime >= startTrans)) {        wallOffscreenPort.setColor(Color.black);        wallPort.setFont(courier12);        wallPort.drawString("Non - steady state", 60, 30);        return;      }      double startTime = 0, initTime = 0, cDoneTime = 0, nucSepTime = 0, stopTime = 0, startGenome = 0;      int startRow = -1, stopRow = -1;      for (int row = 1; row < maxRow; row++) {        if ((typeArr[row] == divideID2) && (timeArr[row] <= thisTime)) {          startRow = row;        }        if ((typeArr[row] == divideID) && (timeArr[row] > thisTime) && (stopRow == -1)) {          stopRow = row;        }      }      startTime = timeArr[startRow];      startGenome = genomeArr[startRow];      for (int row = startRow; row <= stopRow; row++) {        if (typeArr[row] == initID) {          initTime = timeArr[row];        }        if (typeArr[row] == cDoneID) {          cDoneTime = timeArr[row];        }        if (typeArr[row] == nucSepID) {          nucSepTime = timeArr[row];        }      }      stopTime = timeArr[stopRow];      if (nucSepTime >= stopTime) {        nucSepTime = stopTime - 0.1;      }      if (initTime < startTime) {        initTime = startTime;      }      int copiesBefore = copies;      boolean hasDoubled = (thisTime >= cDoneTime);      if (hasDoubled) {        copiesBefore /= 2;      }      if (copiesBefore <= 0) {        return;      }      //double L0 = 1;      double cellGrowth = (thisTime - startTime) / (stopTime - startTime);      double L = 1 + cellGrowth;      double constrState = Math.max(0, (thisTime - nucSepTime) / (stopTime - nucSepTime)); // 0 .. 1      double nucGrowth = range(0, (thisTime - initTime) / (cDoneTime - initTime), 1);      double NucSize = 0.4 * currentGenome / startGenome;      if (hasDoubled) {        NucSize *= 0.5;      }      double offsetStart = NucSize / 2;      double offsetStop = 2.0 / copiesBefore / 4;      double offset = offsetStart + (offsetStop - offsetStart) * (thisTime - cDoneTime) / (stopTime - cDoneTime);      int clones = 2;      if (!hasDoubled) {        clones = 1;        offset = 0;      }      double mag = 100;      //Draw Cell wall      wallPort.setColor(Color.gray);      int dia = 36;      int offy = 6;      double len = (mag * L);      //int ghostPos = round(mag *((L-1)  + L));      int ghostPos = round(mag * (1.3 * L - 0.3));      //int ghostLength = round(1.0 * mag) ;      int partialLen = round(len / 2 + dia / 2 * (1 - constrState));      for (int ghost = 0; ghost < 2; ghost++) {        int ghostOff = ghostPos * ghost;        wallPort.setColor(new Color(100, 100, 100));        if (ghost == 1) {          wallPort.setColor(new Color(175, 175, 175));        }        wallPort.fillRoundRect(ghostOff + 0, offy, partialLen, dia, dia, dia);        wallPort.fillRoundRect(round(ghostOff + len - partialLen), offy, partialLen, dia, dia, dia);      }      if (testFlag2) {        toon("len", len);        toon("partialLen", partialLen);        toon("dia", dia);      }      for (int ghost = 0; ghost < 2; ghost++) {        int ghostOff = ghostPos * ghost;        int cloneNum = 0;        for (int thisNuc = 1; thisNuc <= copiesBefore; thisNuc++) {          double midPos = thisNuc * L / copiesBefore - L / copiesBefore / 2;          for (int thisClone = 1; thisClone <= clones; thisClone++) {            if (clones == 2) {              offset *= -1;            }            //Draw Nucleoides            int startX = (int) (mag * (midPos + offset - NucSize / 2));            int stopX = (int) (mag * (midPos + offset + NucSize / 2));            wallPort.setColor(new Color(255, 255, 160));            if (ghost == 1) {              wallPort.setColor(new Color(190, 190, 190));            }            wallPort.fillRoundRect(ghostOff + startX, offy + 5, stopX - startX, 24, 18, 18);            wallPort.setColor(Color.black);            int charPos = (int) ((startX + stopX) / 2 - 3);            wallPort.setFont(courier9);            if (ghost == 0) {              wallPort.drawString("" + ++cloneNum, charPos, 26);            }            //wallPort.fillOval((int)(midPos * mag -1), 26, 2, 2);            if (testFlag2) {              toon("constrState", L);              toon("NucSize", NucSize);              toon("nucGrowth", nucGrowth);              toon("startX", startX);              toon("stopX", stopX);              toon("offsetStart", offsetStart);              toon("offset", offset);              toon("offsetStop", offsetStop);              toon("midPos", midPos);              toon("--");            }          }        }        if (testFlag2) {          toon("thisTime", thisTime);          toon("startTime", startTime);          toon("initTime", initTime);          toon("cDoneTime", cDoneTime);          toon("nucSepTime", nucSepTime);          toon("stopTime", stopTime);          toon();        }      }    }    /*     * Nucsize example: ---------------- We assume that cellLength at birth is L0=1, at division     * 2*L0, and at thisTime =L (1..2).     *     * In this example, the number of nucs doubles from 4 to 8. At the beginning, we already know     * that we have to squeeze 4 nucs into the cell, in the end, it is 8 nucs, evenly distributed.     *     * We first pinpoint 4 centers as relative cell position: 0.125L, 0.375L, 0.625L, 0.875L.     *     * We use nucsize of 0.25 that completely packs the nucs,-we can reduce later. Note that the     * growth of the nuc is faster in the beginning than the exponential length growth! So the     * limiting factor is the time when the nuc does not grow anymore, i.e. at cDone. Thus we set     * the fixpoint to cDone, calculate the cell length there (e.g. 1.6*L0), pack it there: NucSize     * @cDone = 0.4*L0 Before init, it is startNucSize N0= 0.2 (green band) Between init and cDone,     * it linearly grows from 0.2 to 0.4. After cDone, the split occurs (now 8 nucs) and we again     * have the startNucSize N0 = 0.2.     *     * NucPos example: --------------- Before cDone, we simply place the 4 nucs at the evenly     * distributed 4 centers. After cDone, each nuc is split into a pair, with an offset from the     * center. At cDone, the offset starts at +- startNucSize Until divideID (or nucSep?), it     * linearly grows until +- L/16.     *     *     */  }  public class PlotPanel extends Panel {    public boolean plotDirty = true;    public PlotPanel() {    }    public void update(Graphics g) {      this.paint(g);    }    public void setDirty() {      plotDirty = true;    }    public void setDirty(boolean switchToX) {      plotDirty = true;    }    public void paint(Graphics g) {      setDirty();    }    public void plotPaint(Graphics g) {      plotBusy = true;      Graphics gr = this.getGraphics();      xStart = (int) (-pa.TD1 * preCycles);      xStop = xStart + k480;      myCalc.buildEventChain();      myCalc.enterDivisions();      myCalc.sortEventChain();      myCalc.calcLevels();      myCalc.enterMass();      myCalc.CandD();      myCalc.genomeFromChain();      myCalc.lineFromChain();      myCalc.calcTransitions();      myCalc.showNumbers1();      drawFrame(frameOffscreenPort);      plotOffscreenPort.drawImage(frameOffscreenImg, 0, 0, null);      plotOffscreenPort.setColor(Color.black);      if (checkboxMass.getState()) {        plotOffscreenPort.drawPolyline(massPolyLineX, massPolyLineY, lastPoint1);      }      plotOffscreenPort.setColor(Color.magenta);      if (checkboxGenome.getState()) {//26.9.2006        plotOffscreenPort.drawPolyline(dnaPolyLineX, dnaPolyLineY, lastPoint2);      }      plotOffscreenPort.setColor(new Color(0, 128, 0));      if (checkboxcDNA.getState()) {        plotOffscreenPort.drawPolyline(cDNAPolyLineX, cDNAPolyLineY, lastPoint3);      }      plotOffscreenPort.setColor(new Color(0, 128, 100));      if (checkboxGperNuc.getState()) {        plotOffscreenPort.drawPolyline(iArrX3, iArrY3, lastPoint3);      }      plotOffscreenPort.setColor(Color.black);      for (int x1, x2, y1, y2, ww, row = 1; row < CDlines; row++) {        x1 = CDx1[row];        x2 = CDx2[row];        ww = x2 - x1;        y1 = CDy1[row];        y2 = CDy2[row];        plotOffscreenPort.setColor(CDcolor[row]);        plotOffscreenPort.drawLine(x1, y1, x2, y2);        plotOffscreenPort.drawLine(x1, y1 + 1, x2, y2 + 1);        plotOffscreenPort.drawLine(x1, y1 + 2, x2, y2 + 2);      }      super.paint(plotOffscreenPort);      gr.drawImage(plotOffscreenImg, 0, 0, null);      drawPlotAndTime();      plotDirty = false;      treePanel.setDirty();      wallPanel.setDirty();      plotBusy = false;    }    public void drawPlotAndTime() {      int tim = (int) pa.currentTime;      boolean showFuture = !checkboxAnimatedPlot.getState();      Graphics gr = plotPanel.getGraphics();      if (!showFuture) {        gr.setClip(0, 0, tim + 1, plotPanelHeight);      }      gr.drawImage(plotOffscreenImg, 0, 0, null);      if (showFuture) {        gr.drawLine((int) pa.currentTime, 0, tim, plotPanelHeight);      } else {        gr.setClip(0, 0, k480, plotPanelHeight);        gr.setClip(tim, 0, k480 - tim, plotPanelHeight);        gr.drawImage(frameOffscreenImg, 0, 0, null);      }    }    public void drawFrame(Graphics g) {      Color backColor = new Color(255, 255, 255);      Color trColor = new Color(225, 225, 225);      Color gridColor = new Color(180, 220, 250);      this.setBackground(backColor);      g.setColor(backColor);      g.fillRect(0, 0, plotPanelWidth, plotPanelHeight);      g.setColor(trColor);      g.fillRect((int) startTrans, 0, (int) (stopTrans - startTrans), plotPanelHeight);      g.setColor(gridColor);      for (int y = 0; y < plotPanelHeight; y += octHeight) {        g.drawLine(0, y, plotPanelWidth, y);      }      for (int x = -300; x < 600; x += 30) {        int xx = x - xStart;        if ((xx >= 0) && (xx <= plotPanelWidth)) {          g.drawLine(xx, 0, xx, plotPanelHeight);        }      }      g.setColor(Color.black);      g.drawRect(0, 0, k480 - 1, plotPanelHeight - 1);    }  }  public void flashLabels(Color color) {    for (int ii = 0; ii < labelSet.length; ii++) {      labelSet[ii].setBackground(color);    }    try {      //do what you want to do before sleeping      Thread.currentThread().sleep(500);//sleep for 1000 ms      //do what you want to do after sleeptig    } catch (Exception ie) {//If this thread was intrrupted by nother thread    }    try {      Thread.currentThread().sleep(500);//sleep for 500 ms    } catch (Exception ie) {    }    for (int ii = 0; ii < labelSet.length; ii++) {      labelSet[ii].setBackground(Color.white);    }  }  public void setRunFlagFalse() {    runFlag = false;    wait(100);  }  /**   * Respond to user input events.   */  public boolean action(Event e, Object arg) {    if (e.target == cases) {      setRunFlagFalse();      runButton.setLabel("Run");      int jj = cases.getSelectedIndex();      if (jj < 5) {        //currentCase = jj;        setCase(jj);      }      //numbersArea.setEditable(currentCase == 6);      //if (currentCase < 5) //currentCase = theCase;      //else cases.select(currentCase);      //{      //   setCase(currentCase);      // }//            if (jj == 6) {//Edit numbers//                cases.select(0);//                currentCase = 0;//                numbersToText();//                numbersArea.setText(pa.txt);//                return super.action(e, arg);//            }//            if (jj == 7) {//Apply Numbers//                cases.select(0);//                currentCase = 0;//                definitions[0] = Applet4.numbersArea.getText();//                pa.txt = Applet4.numbersArea.getText();//                se.txtToNumbers(pa);//                updateControls();//                flashLabels(Color.magenta);//                plotPanel.setDirty(false);//            }//            if ((jj != 6) && (jj != 8)) {//                caseDirty = true;//            }      if (jj == 5) {//Swap Parameters        se.swapParameters(pa);        updateControls();        runButton.setLabel("Run");        setRunFlagFalse();        treePanel.setDirty();        plotPanel.setDirty();      }      if (jj == 7) {//Version        numbersArea.setText(versionString);      }      if (jj == 7) {//Copy        String savedText = numbersArea.getText();        numbersToText();        String s = pa.txt;        //clipArea.setEditable(true);        //clipArea.setEnabled(true);        numbersArea.setText(s);        numbersArea.selectAll();        //numbersArea.setBackground(Color.magenta);        //numbersArea.show();        //wait(1000);        //numbersArea.copy(); only works for JTextArea        numbersArea.setText(savedText);      }      if (jj == 8) {//Paste        String savedText = textArea1.getText();        numbersArea.selectAll();        //numbersArea.paste();only works for JTextArea        numbersArea.setVisible(true);        //numbersArea.setBackground(Color.orange);        //numbersArea.show();        //wait(1000);        String s = numbersArea.getText();        numbersArea.setText(savedText);        pa.txt = s;        se.txtToNumbers(pa);        updateControls();      }      cases.select(0);      return true;    }    if (e.target instanceof Checkbox) {      if (e.target == checkboxStraight) {        ASPECT = 0.4;        scrollbarViewAngle.setValue((int) (ASPECT * 100));      }    }    plotPanel.setDirty();    plotAxesPanel.setDirty();    treePanel.setDirty();    return super.action(e, arg);  }  class SimpleThread extends Thread {    public SimpleThread() {      start();    }    public void run() {      try {        sleep(1000);      } catch (Exception e2) {        e2.printStackTrace();      }      doReset();      while (true) {        try {          sleep(20);        } catch (Exception e2) {          e2.printStackTrace();        }        if (initDone) {          if (runFlag) {            pa.currentTime += 0.5;            if (pa.currentTime >= k480) {              pa.currentTime = 0.00022;            }            scrollbarTime.setValue((int) pa.currentTime);            treePanel.setDirty();            plotPanel.drawPlotAndTime();          }          caseDirty = false;          if (plotPanel.plotDirty) {            plotPanel.plotPaint(plotPanel.getGraphics());          }          if (plotAxesPanel.numDirty) {            plotAxesPanel.numPaint(plotAxesPanel.getGraphics());          }          if (treePanel.treeDirty) {            treePanel.treePaint(treePanel.getGraphics());            myCalc.showNumbers2();          }          if (wallPanel.wallDirty) {            wallPanel.wallPaint(wallPanel.getGraphics());          }        }      }    }  }  public class MyParams {    public String txt;//text form    public String name;    public double //initTime,            TD1, C1, D1, N1, TD2, C2, D2, N2 = 5, currentTime = 0, Mi1, Mi2, L1, L2;//number form  }  public static void main(String args[]) {    JFrame frame = new JFrame("Hello Frame");    Applet myApplet = new Applet4();    frame.add(myApplet);    frame.setSize(870, 800);    frame.setVisible(true);    myApplet.init();    myApplet.setVisible(true);  }  public static void wait(int n) {    long t0, t1;    t0 = System.currentTimeMillis();    do {      t1 = System.currentTimeMillis();    } while (t1 - t0 < n);  }}