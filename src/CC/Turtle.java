/*We store only x and y in the array, angle is not stored.However, the current angle of the turtle can be read at any time.Actions like turtleArc and turtleLine do not read the vert array.They read turtleX, turtleY, turtleAngle, then push new values ontothe "stack", and update the globals turtleX, turtleY, turtleAngle.For the fowers, we also store an auxiliary value:the path length travelled at any time. We store this in thepath array, and on return provide the updated global valueturtlePath.pen is a variable that is stored together with the coords.*/public class Turtle extends CCSim_{	final double  k57 = 180 / Math.PI;	static double 	turtleAngle = 0,         // not stored in array	turtleX = 0,             // stored	turtleY = 0,             // stored	turtlePath = 0;          // stored	static int turtlePen = 1;// stored	final static int k2000 = 2000;	static int n_vPtr = 0;	public static double[] n_VertX = new double[k2000];	static double[] n_VertY = new double[k2000];	static double[] n_Path  = new double[k2000];	static int[] n_Pen      = new int[k2000]; //color of previous line	Turtle(){	}void check(){	if (n_vPtr >= k2000)		n_vPtr = k2000-1;	}void turtleSet(double xx, double yy, double angle){	++n_vPtr;	check();	n_Pen[n_vPtr] = turtlePen;	n_Path[n_vPtr] = turtlePath;  n_VertX[n_vPtr] = xx;  n_VertY[n_vPtr] = yy;	turtleX = xx;	turtleY = yy;  turtleAngle = angle;}void turtleReset(double xx, double yy, double angle){	n_vPtr = 1;	turtlePen = 0;	turtlePath = 0;	turtleX = xx;	turtleY = yy;	n_Pen[n_vPtr] = turtlePen;  n_VertX[n_vPtr] = xx;  n_VertY[n_vPtr] = yy;	n_Path[n_vPtr] = turtlePath;  turtleAngle = angle;}void turtleArc(double angle, double radius, int n){double dx, dy,  len, dPhi, turtlePhi, peri ;int j;	if (n == 0) {		peri = Math.abs(radius * angle /k57); //in pixels		n = (int) ( peri/ 2); //automatic: 2 pixels per segment, 		if (n > (Math.abs(angle)/2)) //       {or 2 degrees per segment, }			n = (int) (Math.abs(angle)/2);     //whichever is larger}		}	if (n < 1)		n = 1;  dPhi = -angle / k57 / n / 2; //half step}  turtlePhi = turtleAngle / k57;  for (j = 1; j<= n; j++) {    turtlePhi = turtlePhi + dPhi;    if (j > 1)       turtlePhi = turtlePhi + dPhi;    len = 2 * Math.abs(Math.sin(dPhi)) * radius;    turtlePath += len;    dx = len * Math.cos(turtlePhi);    dy = -len * Math.sin(turtlePhi);    turtleX = turtleX + dx;      turtleY = turtleY + dy;    ++n_vPtr;    check();    n_VertX[n_vPtr] = turtleX;    n_VertY[n_vPtr] = turtleY;    n_Pen[n_vPtr] = turtlePen;    n_Path[n_vPtr] = turtlePath;        }  turtlePhi = turtlePhi + dPhi;  turtleAngle = turtlePhi * k57; }	//void drawFlower(){			//}	void turtleLine(double angle, double radius){	double dx, dy, dPhi, turtlePhi;	int j;	//Applet4 aaa= new CCSim_();	//double a=/*CCSim_.*/Mi1;	  dPhi = -angle / k57;	  turtlePhi = turtleAngle / k57;	  turtlePhi = turtlePhi + dPhi;	  dx = radius * Math.cos(turtlePhi);	  dy = -radius *  Math.sin(turtlePhi);	  turtleX = turtleX + dx;  	  turtleY = turtleY + dy;    ++n_vPtr;    check();		turtlePath += radius;	  n_VertX[n_vPtr] = turtleX;	  n_VertY[n_vPtr] = turtleY;	  n_Pen[n_vPtr] = turtlePen;	  n_Path[n_vPtr] = turtlePath;	  turtleAngle = turtlePhi * k57;	  	}/*	void flower(){		int jj, kk, start, stop;		for (jj=1; jj < flowerLines; jj++){			start = xx1Flower[jj];			stop = xx2Flower[jj];						for (kk = start; kk <= stop; kk++){				//tu.initTurtle							}		}	}*/}