macro " "{//don't change macro name
	plotTitle = "";
	limits = split("");//(left right bottom top); NaN = automatic)
	xColumns = split("");
	yColumns = split("");
	colors = split("");
	qualifyFlags = split("");//a=all, q=qualified, u=unqualified
	types = split("");
	binWidths = split("");
	legend = "dummy";
	legendPosition = "dummy";
	dialogInterface = "true"; //if true, dialog is allowed to change variables above)
//================================
	frameWidth = 600;
	frameHeight= 400;
	legendParts = split(legend, "\n");
	
	//strings to floats:
	for(jj = 0; jj < binWidths.length; jj++)
		binWidths[jj] = parseFloat(binWidths[jj]);
	
	locX = NaN;
	if(isOpen(plotTitle)){
		selectImage(plotTitle);
		getLocationAndSize(locX, locY, ww, hh);
	}
	close(plotTitle);
	if(yColumns.length > 1)
		yTitle = "Y";
	else
		yTitle = yColumns[0];
	Plot.create(plotTitle, xColumns[0],yTitle);
	count = ojNObjects();
	nPlots = yColumns.length;
	legend2 = "";
	for(plot = 0; plot < nPlots; plot++){
		showProgress(plot/nPlots);
		color = colors[plot];
		if(color == "green")
			color = "#00bb00";
		if(color == "cyan")
			color = "#00bbdd";
		Plot.setColor(color); 
		xValues = newArray(count);
		yValues	 = newArray(count);
		yColumn = yColumns[plot];
		qChar = qualifyFlags[plot];
		binWidth = binWidths[plot];
		nPairs = 0;
		for (obj = 1; obj<= ojNObjects(); obj++){
			showProgress(-obj/ojNObjects());
			objQ = ojQualified(obj);
			if (qChar=="a" || objQ && qChar == "q" || !objQ && qChar == "u"){//all, qualified, unqualified
				valx = ojResult(xColumns[plot], obj);
				valy = ojResult(yColumns[plot], obj);
				if (!isNaN(valx + valy)){
					xValues[nPairs] = valx;
					yValues[nPairs] = valy;
					nPairs++;
				}
			}
		}
		if (nPairs > 0){
			xValues = Array.trim(xValues, nPairs);
			yValues = Array.trim(yValues, nPairs);
			theType = types[plot];
			
			if (!startsWith(theType, "error"))
				Plot.add(types[plot], xValues, yValues);
			else{
				addErrorBars(xValues, yValues, binWidth);
			}
			legend2 += legendParts[plot] + "\n";
		}
	}
	if(limits.length ==4){
		Plot.setLimits(limits[0], limits[1], limits[2], limits[3]);
	}
	else
		Plot.setLimitsToFit();
	Plot.setFrameSize(frameWidth, frameHeight);
	if (legend != "")
		Plot.setLegend(legend2, legendPosition);
	Plot.show;
	if (!isNaN(locX))
		setLocation(locX, locY);
}



function addErrorBars(xValues, yValues, binWidth){//eg binWidth = 0.5
	//k90 = 1.645, k95 = 1.9600, k98 = 2.3264, k99 = 2.5758;
	confid = 1.9600;//95%
	Array.getStatistics(xValues, min, max, mean, stdDev);
	if (!(binWidth > 0))
		binWidth = (max - min)/5;
	xStart = min;

	binnedXValues = newArray (500);
 	binnedYValues = newArray (500);
	binnedErrorBars = newArray (500);
	midBins = newArray(500);
	group = newArray (9000);
	len = xValues.length;
	rankPArr = Array.rankPositions(xValues);
	count = 0;	
	nBins = 0;//need not be contiguous	
			
	for (jj = 0; jj < len; jj++){
		index = rankPArr[jj];//start with smallest value
		xVal = xValues[index];
		yVal = yValues[index];
		bin = floor((xVal - xStart)/binWidth);//0, 1, 2...
		full =	(jj == (len -1));
		if (!full){
			nextIndex = rankPArr[jj + 1];
			nextBin = floor((xValues[nextIndex] - xStart)/binWidth);
			full = bin != nextBin;
		}
		group[count++] = yVal;
		if (full && count > 1){
			//showProgress(jj/len);
			group = Array.trim(group, count);
			Array.getStatistics(group, min, max, mean, stdDev);
			midBin = xStart + binWidth * bin + binWidth/2;
			binnedXValues[nBins] = midBin;//0, 0.5, 1
			binnedYValues[nBins] = mean;
			binnedErrorBars[nBins] = confid*stdDev/sqrt(count); 
			group = newArray (9000);
			count = 0;
			nBins++;
		}
		if (full) count =0;
	}
	binnedXValues = Array.trim(binnedXValues, nBins);
	binnedYValues = Array.trim(binnedYValues, nBins);
	binnedErrorBars = Array.trim(binnedErrorBars, nBins);
	
	
	Plot.setLineWidth(2);
	Plot.add("line", binnedXValues, binnedYValues);
	Plot.add("error bars", binnedErrorBars);
	Plot.setLineWidth(1);
}
